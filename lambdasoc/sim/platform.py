import sys

from collections import OrderedDict
from importlib import import_module, resources

from amaranth import *
from amaranth.build import *


__all__ = ["CXXRTLPlatform"]


class CXXRTLPlatform(TemplatedPlatform):
    device      = "cxxrtl"
    default_clk = "clk"
    default_rst = "rst"
    resources   = [
        Resource("clk", 0, Pins("clk", dir="i"), Clock(5e6)),
        Resource("rst", 0, Pins("rst", dir="i")),
    ]
    connectors  = []
    toolchain   = None # selected when creating platform

    file_templates = {
        **TemplatedPlatform.build_script_templates,
        "{{name}}.il": r"""
            # {{autogenerated}}
            {{emit_rtlil()}}
        """,
        "{{name}}.ys": r"""
            # {{autogenerated}}
            {% for file in platform.iter_files(".v") -%}
                read_verilog {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_files(".sv") -%}
                read_verilog {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_files(".il") -%}
                read_ilang {{file}}
            {% endfor %}
            read_ilang {{name}}.il
            delete w:$verilog_initial_trigger
            {{get_override("script_after_read")|default("# (script_after_read placeholder)")}}
            write_cxxrtl {{get_override("write_cxxrtl_opts")|options}} -header {{name}}.cc
        """,
        "{{name}}.mk": r"""
            # {{autogenerated}}
            CC       = $(CXX)
            CPPFLAGS = -Ilambdasoc.sim/include -include {{name}}.h -MMD \
                       -I{{get_override("yosys_include_dir")|default("/usr/local/share/yosys/include")}} \
                       {{get_override("additional_cpp_flags")|default("# (additional_cpp_flags placeholder)")}}
            CXXFLAGS = {{get_override("cxx_flags")|default("-std=c++14 -Wall -O3 -mtune=native")}}
            LDFLAGS  = {{get_override("ld_flags")|default("# (ld_flags placeholder)")}}
            LDLIBS   = {{get_override("ld_libs")|default("# (ld_libs placeholder)")}}

            SRC  = {{name}}.cc \
            {% for file in platform.iter_files(".cc") %}
                   {{file}} \
            {% endfor %}

            OBJS = $(SRC:.cc=.o)
            DEPS = $(OBJS:.o=.d)

            .PHONY: all clean

            all: {{name}}_driver

            -include DEPS

            {% set tab = ""|indent(width="\t", first=True) -%}

            {% for file in platform.iter_files(".v", ".sv", ".il") %}
            {{name}}.cc {{name}}.h: {{file}}
            {% endfor %}
            {{name}}.cc {{name}}.h: {{name}}.ys {{name}}.il
            {{tab}}$(YOSYS) -s {{name}}.ys

            {{name}}_driver.o: CPPFLAGS += -DCXXRTL_TOP='cxxrtl_design::p_{{name}}'

            $(OBJS): {{name}}.h

            {{name}}_driver: $(OBJS)

            clean:
            {{tab}}rm -f {{name}}.cc {{name}}.h
            {{tab}}rm -f $(OBJS) $(DEPS)
            {{tab}}rm -f {{name}}_driver
        """,
    }

    # GCC templates

    _gcc_required_tools = [
        "yosys",
        "g++",
        "make",
    ]
    _gcc_command_templates = [
        r"""
            YOSYS={{invoke_tool("yosys")}}
            CXX={{invoke_tool("g++")}}
            {{invoke_tool("make")}} -f {{name}}.mk
        """,
    ]

    # Clang templates

    _clang_required_tools = [
        "yosys",
        "clang++",
        "make",
    ]
    _clang_command_templates = [
        r"""
            YOSYS={{invoke_tool("yosys")}}
            CXX={{invoke_tool("clang++")}}
            {{invoke_tool("make")}} -f {{name}}.mk
        """,
    ]

    def __init__(self, *, toolchain="clang"):
        super().__init__()

        assert toolchain in ("gcc", "clang")
        self.toolchain = toolchain

    @property
    def required_tools(self):
        if self.toolchain == "gcc":
            return self._gcc_required_tools
        if self.toolchain == "clang":
            return self._clang_required_tools
        assert False

    @property
    def command_templates(self):
        if self.toolchain == "gcc":
            return self._gcc_command_templates
        if self.toolchain == "clang":
            return self._clang_command_templates
        assert False

    def create_missing_domain(self, name):
        if name == "sync":
            m = Module()
            clk_i = self.request(self.default_clk).i
            rst_i = self.request(self.default_rst).i
            m.domains.sync = ClockDomain("sync")
            m.d.comb += [
                ClockSignal("sync").eq(clk_i),
                ResetSignal("sync").eq(rst_i),
            ]
            return m

    def toolchain_prepare(self, fragment, name="top", blackboxes=None, **kwargs):
        if blackboxes is None:
            blackboxes = OrderedDict()

        def get_cxxrtl_src(package):
            cxxrtl_src = OrderedDict()
            assert hasattr(package, "cxxrtl_src_files")
            for module, subdirs, src_file in package.cxxrtl_src_files:
                src_contents = resources.read_text(module, src_file)
                src_path = "/".join((package.__name__, *subdirs, src_file))
                cxxrtl_src[src_path] = src_contents
            return cxxrtl_src

        cxxrtl_src = {
            f"{name}_driver.cc": resources.read_text(__package__, "top_driver.cc"),
            **get_cxxrtl_src(sys.modules[__package__]),
        }

        for blackbox_name, driver_name in blackboxes.items():
            blackbox = import_module(blackbox_name)
            blackbox_contents = resources.read_text(blackbox, "blackbox.v")
            blackbox_path = f"{blackbox_name}/blackbox.v"
            self.add_file(blackbox_path, blackbox_contents)

            driver = import_module(f"{blackbox_name}.drivers.{driver_name}")
            cxxrtl_src.update(get_cxxrtl_src(driver))

        for cxxrtl_src_path, cxxrtl_src_contents in cxxrtl_src.items():
            self.add_file(cxxrtl_src_path, cxxrtl_src_contents)

        return super().toolchain_prepare(fragment, name=name, **kwargs)
